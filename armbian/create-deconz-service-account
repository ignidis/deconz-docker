#!/bin/bash
#
# We will use the docker user namespace remapping functionality to isolate our containers
#
# This is the service account we will use to start the docker containers
# The service account is owns the host volumes to store the persistent configuration and avoids starting containers as host root users
# In the container we should also define application users and avoid running these as root
#

SERVICE_USER="service";
SERVICE_USER_UID="9001";
SERVICE_GROUP="services";
SERVICE_GROUP_UID="9001";
ADD_GROUPS="sudo"

#
# Create service group and service account
#
userdel $SERVICE_USER >/dev/null 2>&1;
groupdel $SERVICE_GROUP >/dev/null 2>&1;

groupadd -g $SERVICE_GROUP_UID $SERVICE_GROUP;
useradd -u $SERVICE_USER_UID -g $SERVICE_GROUP --groups $ADD_GROUPS --shell /bin/bash --create-home $SERVICE_USER;
chown -R $SERVICE_USER:$SERVICE_GROUP /home/$SERVICE_USER/;

#
# Create the docker subuid and subgui files to allow for namespace remaping of the container.
# Namespace remaping -once configured in the docker daemon- starts the container as a host-unprivileged user, thus adding another
# security layer to the container already running internally as non-root
# In case of a privilege elevation exploit in the container, the host docker process must also be defeated and elevated to a host root
# The user mapping starts by assigning container uid/gid 0 to the UID/GID assigned and counting up.
# We allocate 65532 UIDs (GUIs) for the mapping, we must make sure ALL standard Linux UIDs/GIDs are contained in the range or setuid will fail for IDs 
# not remapped (e.g. apt-get update uses GID 65534 for nobody)
# We can select the internal container user by adding the initial UID of the range to the internal UID
# (container user 9001 would then be host user SERVICE_USER_UID + 9001 thank becomes handy when we assign the ACL or ownership for the permanent storage
# KEEP IN MIND the INTERNAL CONTAINER USERS are remapped when we look from the host side (e.g. container root is SERVICE_USER_ID in the host)
#

echo "${SERVICE_USER}:${SERVICE_USER_UID}0000:65536" > /etc/subuid
echo "${SERVICE_GROUP}:${SERVICE_GROUP_UID}0000:65536" > /etc/subgid

#
# Create persistent config directory, will be exposed as volume to the docker container
#
if [ ! -d "/var/lib/services/deconz" ]; then
    mkdir -p /var/lib/services/deconz/;
fi
if [ ! -d "/var/lib/services/node-red" ]; then
    mkdir -p /var/lib/services/node-red/;
fi
if [ ! -d "/var/lib/services/openhab" ]; then
    mkdir -p /var/lib/services/openhab/;
fi
#
# Ensure that the container root user has access to the mounted container directories
#
#chown -R "${SERVICE_USER_ID}0000":"${SERVICE_GROUP_UID}0000" /var/lib/services/deconz/;
#chown -R "${SERVICE_USER_ID}0000":"${SERVICE_GROUP_UID}0000" /var/lib/services/node-red/;
#chown -R "${SERVICE_USER_ID}0000":"${SERVICE_GROUP_UID}0000" /var/lib/services/openhab/;
#
# Where we know that the container service user is the one that will need access -and we know it's container id- we just change the ownership
# That will remove the need to grant the container user sudo rights, even for the first start of the container
#
chown -R "${SERVICE_USER_ID}9001":"${SERVICE_GROUP_UID}9001" /var/lib/services/deconz/;
chown -R "${SERVICE_USER_ID}9001":"${SERVICE_GROUP_UID}9001" /var/lib/services/node-red/;
chown -R "${SERVICE_USER_ID}9001":"${SERVICE_GROUP_UID}9001" /var/lib/services/openhab/;

#
# Create the systemd service scripts in order to start the containers composing the system
#
#ln /home/"${SERVICE_USER}"/deconz/systemd/deconz-docker@.service /etc/systemd/system/deconz-docker@.service
#systemctl enable deconz-docker@"${SERVICE_USER}"
#systemctl start deconz-docker@"${SERVICE_USER}"

#ln /home/"${SERVICE_USER}"/node-red/systemd/nodered-docker@.service /etc/systemd/system/nodered-docker@.service
#systemctl enable nodered-docker@"${SERVICE_USER}"
#systemctl start deconz-docker@"${SERVICE_USER}"

